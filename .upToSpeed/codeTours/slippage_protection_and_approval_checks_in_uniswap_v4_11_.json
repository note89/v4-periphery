{"title":"Slippage Protection and Approval Checks in Uniswap v4","id":"evNJ3dVAtc0U2UOTQqT+YjWx7/UKrexWN/fE1+Y3m7M=","steps":[{"type":"textOnly","description":"Welcome to this code tour on **slippage protection** and **approval checks** in `Uniswap v4 Periphery`. We'll explore how these critical mechanisms are implemented to ensure secure and efficient liquidity management. ","title":"","id":"66"},{"type":"revealFiles","files":["src/libraries/SlippageCheck.sol"],"description":"The `SlippageCheck` library is a crucial component of **Uniswap v4's** slippage protection mechanism. It provides two main functions: `validateMinOut` and `validateMaxIn`. These functions are designed to protect users from unexpected price movements during liquidity operations. Let's examine each function in detail.","title":"","id":"84"},{"type":"highlight","description":"The `validateMinOut` function ensures that the amount of tokens received when removing liquidity meets the user's minimum expectations. It's called during **burn** or **decrease** operations.\n\nKey points:\n1. It takes a `BalanceDelta` and minimum amounts for both tokens.\n2. The function expects positive deltas, as tokens are being returned to the user.\n3. It uses `SafeCast` to convert the delta to `uint128`, which will revert if the delta is negative.\n4. If either token amount is less than the specified minimum, it reverts with a `MinimumAmountInsufficient` error.\n\nNote: This function does not support pools where hooks can return negative deltas on **burn**/**decrease** operations.","file":"src/libraries/SlippageCheck.sol","highlight":[{"start":15,"end":31}],"title":"","id":"85"},{"type":"highlight","description":"The `validateMaxIn` function ensures that the amount of tokens required to add liquidity doesn't exceed the user's maximum specified amounts. It's called during mint or increase operations.\n\nKey points:\n1. It takes a `BalanceDelta` and maximum amounts for both tokens.\n2. The function expects negative deltas, as tokens are being taken from the user.\n3. It handles cases where hooks might return positive deltas (crediting tokens to the user).\n4. If either token amount exceeds the specified maximum, it reverts with a `MaximumAmountExceeded` error.\n\n**Note:** This function does not support positive slippage checks on pools where hooks return positive deltas on mint/increase operations.","file":"src/libraries/SlippageCheck.sol","highlight":[{"start":33,"end":52}],"title":"","id":"86"},{"type":"textOnly","description":"When auditing the `SlippageCheck` library, consider the following:\n\n1. **Edge Cases**: Pay attention to scenarios involving extremely small or large token amounts, as well as cases where hooks modify liquidity in unexpected ways.\n\n2. **Precision Loss**: The use of `uint128` for token amounts might lead to precision loss in certain situations. Evaluate if this could be exploited.\n\n3. **Hook Interactions**: The library's behavior changes based on hook interactions. Ensure that this doesn't introduce vulnerabilities when combined with custom hooks.\n\n4. **Gas Optimization**: Assess if the current implementation is gas-efficient, especially for frequently called functions.\n\n5. **Compatibility**: Verify that these functions work correctly with all supported pool types and configurations in Uniswap v4.\n\nUnderstanding these aspects is crucial for ensuring the robustness and security of the slippage protection mechanism in Uniswap v4.","title":"","id":"87"},{"type":"revealFiles","files":["src/base/ERC721Permit_v4.sol"],"description":"The `ERC721Permit_v4` contract extends the ERC721 standard with permit functionality, enabling **gasless approvals**. This powerful feature allows token owners to authorize third-party transfers without directly interacting with the contract, saving on gas fees. Let's examine the two key functions: `permit` and `permitForAll`.","title":"","id":"88"},{"type":"highlight","description":"The `permit` function allows for gasless approval of a specific token. Here's how it works:\n\n1. It takes parameters for the `spender`, `tokenId`, `deadline`, `nonce`, and `signature`.\n2. The `checkSignatureDeadline` modifier ensures the transaction isn't processed after the deadline.\n3. The function retrieves the token owner's address.\n4. It creates a hash of the permit data using `ERC721PermitHash.hashPermit`.\n5. The signature is verified against the hash and the owner's address.\n6. An **unordered nonce** is used to prevent **replay attacks**.\n7. Finally, it calls `_approve` to set the approval.","file":"src/base/ERC721Permit_v4.sol","highlight":[{"start":26,"end":40}],"title":"","id":"89"},{"type":"highlight","description":"The `permitForAll` function enables gasless approval for all tokens of an owner. Its process is similar to `permit`, with some key differences:\n\n1. It includes an `approved` boolean parameter to set or revoke approval.\n2. The function uses `ERC721PermitHash.hashPermitForAll` for creating the digest.\n3. After verification, it calls `_approveForAll` instead of `_approve`.\n\nThis function is particularly useful for contracts or addresses that need to manage multiple tokens on behalf of the owner.","file":"src/base/ERC721Permit_v4.sol","highlight":[{"start":42,"end":56}],"title":"","id":"90"},{"type":"textOnly","description":"When auditing the `ERC721Permit_v4` contract, consider the following security aspects:\n\n1. **Signature Verification**: Ensure that the `signature.verify()` method is robust and correctly implemented.\n2. **Nonce Management**: The `_useUnorderedNonce` function should properly manage nonces to prevent replay attacks.\n3. **Deadline Checks**: Verify that the `checkSignatureDeadline` modifier effectively prevents the processing of expired permits.\n4. **Access Control**: Confirm that only valid owners can create permits for their tokens.\n5. **Gas Considerations**: Assess the gas costs of these functions, especially in scenarios with frequent permit creations.\n\nThese permit functions add complexity to the contract, so thorough testing and potentially formal verification should be considered to ensure their correctness and security.","title":"","id":"91"},{"type":"textOnly","description":"The `PositionManager` contract is central to liquidity management in **Uniswap v4**. It implements crucial functions for modifying liquidity positions while ensuring proper slippage protection. We'll examine four key internal functions: `_increase`, `_decrease`, `_mint`, and `_burn`. Each of these functions incorporates slippage checks to protect users from unexpected price movements during liquidity operations.","title":"","id":"92"},{"type":"highlight","description":"Let's start with the `_increase` function:\n\n1. The function takes parameters including `tokenId`, `liquidity` to add, maximum amounts (`amount0Max`, `amount1Max`), and `hookData`.\n2. It uses the `onlyIfApproved` modifier to ensure the caller is authorized.\n3. After retrieving pool and position info, it calls `_modifyLiquidity` to update the position.\n4. The key slippage check occurs on line 250, where `validateMaxIn` is called on the difference between `liquidityDelta` and `feesAccrued`.\n\nThis check ensures that the actual amounts of tokens required to increase liquidity do not exceed the specified maximums, protecting users from unexpected price changes.","file":"src/PositionManager.sol","highlight":[{"start":236,"end":251}],"title":"","id":"93"},{"type":"highlight","description":"Now, let's analyze the `_decrease` function:\n\n1. Similar to `_increase`, it takes `tokenId`, `liquidity` (to remove), minimum amounts (`amount0Min`, `amount1Min`), and `hookData`.\n2. It also uses the `onlyIfApproved` modifier for authorization.\n3. The `_modifyLiquidity` call uses a negative liquidity value to decrease the position.\n4. The critical difference is on line 267, where `validateMinOut` is called instead of `validateMaxIn`.\n\nThis check ensures that the amounts of tokens received from decreasing liquidity are not less than the specified minimums, protecting users from receiving fewer tokens than expected due to price changes.","file":"src/PositionManager.sol","highlight":[{"start":253,"end":268}],"title":"","id":"94"},{"type":"highlight","description":"Let's examine the `_mint` function:\n\n1. It takes parameters for creating a new position, including `poolKey`, tick range, `liquidity`, maximum amounts, `owner`, and `hookData`.\n2. The function mints a new **NFT** representing the position (lines 280-286).\n3. It initializes and stores the position info (lines 289-290).\n4. The function stores the `poolKey` if it's not already stored (lines 294-297).\n5. Finally, it calls `_modifyLiquidity` to add the initial liquidity.\n6. The slippage check is performed on line 302 using `validateMaxIn`.\n\nThis ensures that the actual amounts of tokens required to create the position do not exceed the specified maximums, protecting users during position creation.","file":"src/PositionManager.sol","highlight":[{"start":270,"end":303}],"title":"","id":"95"},{"type":"highlight","description":"Finally, let's examine the `_burn` function:\n\n1. It takes `tokenId`, minimum amounts (`amount0Min`, `amount1Min`), and `hookData`.\n2. The function uses the `onlyIfApproved` modifier for authorization.\n3. It retrieves the position info and current liquidity (**lines 310-312**).\n4. The position info is cleared, and the NFT is burned (**lines 315-317**).\n5. If there's non-zero liquidity, it calls `_modifyLiquidity` to remove all remaining liquidity.\n6. The slippage check is performed on **line 324** using `validateMinOut`.\n\nThis check ensures that the amounts of tokens received from burning the position are not less than the specified minimums, protecting users when they close their positions completely.","file":"src/PositionManager.sol","highlight":[{"start":305,"end":328}],"title":"","id":"96"},{"type":"textOnly","description":"In summary, the `PositionManager` contract implements robust slippage protection mechanisms across all liquidity operations:\n\n- For adding liquidity (`_increase` and `_mint`), it uses `validateMaxIn` to ensure users don't pay more than expected.\n- For removing liquidity (`_decrease` and `_burn`), it uses `validateMinOut` to ensure users receive at least the minimum expected amounts.\n\nThese checks, combined with the `onlyIfApproved` modifier for authorization, provide a comprehensive safety net for users interacting with liquidity positions in **Uniswap v4**.","title":"","id":"97"},{"type":"highlight","description":"Let's analyze a critical test for slippage protection in liquidity operations. This test case is particularly important from an audit perspective as it verifies the contract's behavior under realistic market conditions.\n\nThe test `test_increaseLiquidity_slippage_revert_swap` simulates a scenario where:\n1. A position is minted\n2. A swap occurs, changing the pool's price\n3. An attempt is made to increase liquidity with tight slippage parameters\n\n**Key audit considerations:**\n- Slippage calculation accuracy\n- Proper revert behavior\n- Interaction between swap and liquidity operations\n\nExamine the test closely, noting how it sets up the scenario and verifies the expected **revert condition**.","file":"test/position-managers/IncreaseLiquidity.t.sol","highlight":[{"start":591,"end":615}],"title":"","id":"70"},{"type":"highlight","description":"Now, let's examine a **test** for the `permit` functionality. This test fuzzes the `permit` function to ensure it correctly sets approvals and handles `nonces`.","file":"test/position-managers/Permit.t.sol","highlight":[{"start":220,"end":239}],"title":"","id":"71"},{"type":"textOnly","description":"Let's apply our understanding of slippage protection through a practical exercise:\n\n1. Open the `SlippageCheck` library (`src/libraries/SlippageCheck.sol`).\n2. In the `validateMaxIn` function, modify the condition on line 46:\n   Change `amount0Max < uint128(uint256(-amount0))` to `amount0Max < uint128(uint256(-amount0)) * 2`.\n3. Make a similar change for `amount1Max` on line 49.\n4. Run the test suite, focusing on `test_increaseLiquidity_slippage_revert_swap` in `IncreaseLiquidity.t.sol`.\n5. Observe how this change affects the test results. What happens to the slippage tolerance?\n\nThis exercise demonstrates how adjusting slippage thresholds impacts liquidity operations and highlights the delicate balance between protection and flexibility in DeFi protocols.","title":"","id":"72"},{"type":"textOnly","description":"This tour has covered the key aspects of **slippage protection** and **approval checks** in `Uniswap v4 Periphery`. Understanding these mechanisms is crucial for ensuring secure and efficient operations in decentralized exchanges.","title":"","id":"73"}]}